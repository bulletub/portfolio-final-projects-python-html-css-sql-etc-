<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Philippines Weather Analyzer Dashboard</title>

  <!-- Charts now are PNGs generated by Python, so no Chart.js needed -->
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">

  <!-- Leaflet (for the map only) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- HTMX (Python-driven partial updates / no custom JS needed) -->
  <script src="https://unpkg.com/htmx.org@1.9.12"></script>
  
  <style>
    /* Splash Screen Styles */
    #splashScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #1e3c72 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      transition: opacity 0.5s ease, visibility 0.5s ease;
    }
    
    #splashScreen.fade-out {
      opacity: 0;
      visibility: hidden;
    }
    
    #splashContent {
      text-align: center;
      animation: fadeInUp 1s ease;
    }
    
    #splashImage {
      max-width: 400px;
      width: 90%;
      height: auto;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      margin-bottom: 20px;
    }
    
    #splashText {
      color: #fff;
      font-size: 24px;
      font-weight: 600;
      margin-top: 20px;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    
    #splashLoader {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid #4fc3f7;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }
    
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <!-- Splash Screen -->
  <div id="splashScreen">
    <div id="splashContent">
      <img id="splashImage" src="{{ url_for('static', filename='images/image analyzer.png') }}" alt="Weather Analyzer">
      <div id="splashText">Weather Analyzer</div>
      <div id="splashLoader"></div>
    </div>
  </div>
  <div id="pageShell">
    {% include "_page_shell.html" %}
  </div>

  <!-- Minimal JS: handle Leaflet clicks -> call Flask via HTMX -->
<script>
// Store current location marker globally
let currentLocationMarker = null;
let mapInstance = null;

function initLeafletMap() {
  const mapContainer = document.getElementById("mapContainer");
  if (!mapContainer) return;

  // üßπ Clear any existing Leaflet instance
  if (mapContainer._leaflet_id) {
    mapContainer._leaflet_id = null;
  }

  // üìç Get current location from data attributes or URL params
  let currentLat = 12.8797; // Default: Philippines center
  let currentLon = 121.7740;
  let currentPlace = "Philippines";
  let zoomLevel = 6;

  // Try to get from data attributes
  const mapDiv = document.getElementById("map");
  if (mapDiv) {
    const dataLat = mapDiv.getAttribute("data-lat");
    const dataLon = mapDiv.getAttribute("data-lon");
    if (dataLat && dataLon) {
      currentLat = parseFloat(dataLat);
      currentLon = parseFloat(dataLon);
      zoomLevel = 10; // Zoom in when location is specified
    }
  }

  // Try to get from URL params (for persistence)
  const urlParams = new URLSearchParams(window.location.search);
  const urlLat = urlParams.get("lat");
  const urlLon = urlParams.get("lon");
  if (urlLat && urlLon) {
    currentLat = parseFloat(urlLat);
    currentLon = parseFloat(urlLon);
    zoomLevel = 10;
    currentPlace = urlParams.get("place") || "Selected Location";
  }

  // Philippines bounds (approximate)
  const philippinesBounds = L.latLngBounds(
    [4.2, 116.9],  // Southwest (South, West)
    [21.1, 127.0]  // Northeast (North, East)
  );

  // Validate and constrain coordinates to Philippines
  function validatePhilippinesCoordinates(lat, lon) {
    if (lat < 4.2 || lat > 21.1 || lon < 116.9 || lon > 127.0) {
      return false;
    }
    return true;
  }

  // Constrain coordinates to Philippines bounds
  function constrainToPhilippines(lat, lon) {
    lat = Math.max(4.2, Math.min(21.1, lat));
    lon = Math.max(116.9, Math.min(127.0, lon));
    return { lat, lon };
  }

  // Ensure current location is within Philippines
  const constrained = constrainToPhilippines(currentLat, currentLon);
  currentLat = constrained.lat;
  currentLon = constrained.lon;

  // üó∫Ô∏è Initialize map centered on current location with Philippines bounds
  const map = L.map(mapContainer, {
    zoomControl: true,
    attributionControl: true,
    maxBounds: philippinesBounds,
    maxBoundsViscosity: 1.0  // Prevent panning outside bounds
  }).setView([currentLat, currentLon], zoomLevel);
  mapInstance = map; // Store globally

  // Limit zoom level to keep view within Philippines
  map.setMinZoom(6);
  map.setMaxZoom(14);  // Prevent zooming too close

  // üß± Add base tile layer
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 18,
    attribution: "&copy; OpenStreetMap contributors",
  }).addTo(map);

  // Enforce bounds when map is moved
  map.on('dragend', function() {
    const center = map.getCenter();
    if (!philippinesBounds.contains(center)) {
      const constrained = constrainToPhilippines(center.lat, center.lng);
      map.setView([constrained.lat, constrained.lon], map.getZoom());
    }
  });

  // Enforce bounds when zoomed
  map.on('zoomend', function() {
    const center = map.getCenter();
    if (!philippinesBounds.contains(center)) {
      const constrained = constrainToPhilippines(center.lat, center.lng);
      map.setView([constrained.lat, constrained.lon], map.getZoom());
    }
  });

  // Function to handle map clicks - PIN LOCATION
  function setupMapClickHandler() {
    // Remove any existing click handlers to avoid duplicates
    if (map) {
      map.off("click");
    }
    
    // Wait for map to be fully ready before attaching click handler
    map.whenReady(function() {
      map.on("click", async function (e) {
        console.log("Map clicked!", e.latlng); // Debug log
        
        // Ignore clicks on markers, popups, or controls
        if (e.originalEvent) {
          const target = e.originalEvent.target;
          if (target.closest('.leaflet-popup') || 
              target.closest('.leaflet-marker-icon') || 
              target.closest('.leaflet-control') ||
              target.closest('.search-container')) {
            console.log("Click ignored on", target); // Debug log
            return;
          }
        }
        
        let lat = e.latlng.lat;
        let lon = e.latlng.lng;
        
        // Validate coordinates are within Philippines
        if (!validatePhilippinesCoordinates(lat, lon)) {
          const constrained = constrainToPhilippines(lat, lon);
          lat = constrained.lat;
          lon = constrained.lon;
          
          // Show warning
          L.popup()
            .setLatLng([lat, lon])
            .setContent("‚ö†Ô∏è Location outside Philippines. Constrained to nearest valid location.")
            .openOn(map);
          
          setTimeout(() => map.closePopup(), 3000);
        }
        
        let placeName = "Pinned Location";

        console.log("Processing click for:", lat, lon); // Debug log

        // Show loading indicator
        const loadingPopup = L.popup()
          .setLatLng([lat, lon])
          .setContent("üîç Getting location info...")
          .openOn(map);

        try {
          // Ensure coordinates are validated before reverse geocoding
          if (!validatePhilippinesCoordinates(lat, lon)) {
            placeName = "Location outside Philippines";
            map.closePopup(loadingPopup);
            L.popup()
              .setLatLng([lat, lon])
              .setContent("‚ö†Ô∏è This location is outside the Philippines. Weather data is only available for locations within the Philippines.")
              .openOn(map);
            return; // Don't proceed with weather update
          }
          
          const response = await fetch(
            `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&countrycodes=ph`
          );
          const data = await response.json();
          
          // Check if location is in Philippines
          if (data.address && data.address.country_code && data.address.country_code.toLowerCase() !== 'ph') {
            placeName = "Location outside Philippines";
            map.closePopup(loadingPopup);
            L.popup()
              .setLatLng([lat, lon])
              .setContent("‚ö†Ô∏è This location is outside the Philippines. Weather data is only available for locations within the Philippines.")
              .openOn(map);
            return; // Don't proceed with weather update
          }
          
          if (data.address && (data.address.city || data.address.town || data.address.village || data.address.municipality)) {
            placeName = data.address.city || data.address.town || data.address.village || data.address.municipality;
          } else if (data.address && data.address.state) {
            placeName = data.address.state;
          } else if (data.display_name) {
            const parts = data.display_name.split(",");
            placeName = parts[0] || "Pinned Location";
          }
        } catch (err) {
          console.error("Reverse geocoding failed:", err);
        }

        map.closePopup(loadingPopup);

        // Update URL to persist location
        const url = new URL(window.location);
        url.searchParams.set("lat", lat);
        url.searchParams.set("lon", lon);
        url.searchParams.set("place", placeName);
        window.history.pushState({}, "", url);

        // Remove old pinned marker
        if (currentLocationMarker) {
          map.removeLayer(currentLocationMarker);
        }

        // Add pin marker with distinctive icon
        const pinIcon = L.divIcon({
          className: 'current-location-marker pinned-location',
          html: '<div style="background-color: #ff6b6b; width: 24px; height: 24px; border-radius: 50% 50% 50% 0; transform: rotate(-45deg); border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.4); position: relative;"><div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(45deg); width: 8px; height: 8px; background: white; border-radius: 50%;"></div></div>',
          iconSize: [24, 24],
          iconAnchor: [12, 24]
        });
        
        currentLocationMarker = L.marker([lat, lon], { icon: pinIcon, draggable: false })
          .addTo(map)
          .bindPopup(`üìç ${placeName}<br><small>Weather data loading...</small>`, { autoClose: false })
          .openPopup();
        
        // Zoom to pinned location
        map.setView([lat, lon], 12);

        // Check if pinned location matches any city and update dropdown
        const matchingCity = findMatchingCity(lat, lon);
        const citySelect = document.getElementById("citySelect");
        if (matchingCity && citySelect) {
          // Clear selection or set to matching city
          citySelect.value = matchingCity;
          
          // Also update hidden inputs
          const hiddenLat = document.getElementById("hiddenLat");
          const hiddenLon = document.getElementById("hiddenLon");
          const hiddenPlace = document.getElementById("hiddenPlace");
          if (hiddenLat) hiddenLat.value = lat.toString();
          if (hiddenLon) hiddenLon.value = lon.toString();
          if (hiddenPlace) hiddenPlace.value = placeName;
        } else if (citySelect) {
          // If no matching city, ensure dropdown doesn't have a selected city value
          // Keep current selection or set to first option
          // Don't clear it automatically, let user choose
        }

        // Automatically update weather analysis when pinning location
        updateWeatherWithLocation(lat, lon, placeName);
      });
      
      console.log("Map click handler attached successfully"); // Debug log
    });
  }

  // Setup click handler - will attach when map is ready
  setupMapClickHandler();

  // Wait for map to be ready before adding search box
  map.whenReady(function() {
    // üîç Search Box with Suggestions (Integrated in Map) - Add after map is ready
    const searchBox = L.control({ position: "topright" });
    searchBox.onAdd = function () {
      const div = L.DomUtil.create("div", "search-container");
      div.innerHTML = `
        <div class="search-wrapper">
          <div class="search-icon-wrapper">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="search-icon">
              <circle cx="11" cy="11" r="8"></circle>
              <path d="m21 21-4.35-4.35"></path>
            </svg>
          </div>
          <input
            type="text"
            id="mapSearchInput"
            placeholder="Search place in Philippines..."
            class="map-search-input"
          />
          <div id="searchSuggestions" class="search-suggestions"></div>
        </div>
      `;
      
      // Prevent map click propagation on search container
      L.DomEvent.disableClickPropagation(div);
      L.DomEvent.disableScrollPropagation(div);
      
      return div;
    };
    searchBox.addTo(map);

    // Initialize search functionality after search box is added
    setTimeout(() => {
      initializeSearchBox(map);
    }, 100);
  });

  // üìç Remove old current location marker if exists
  if (currentLocationMarker) {
    map.removeLayer(currentLocationMarker);
    currentLocationMarker = null;
  }

  // üìç Add persistent marker for current location (if we have specific coordinates)
  if (currentLat !== 12.8797 || currentLon !== 121.7740 || urlLat) {
    // Use a distinctive icon for the current location
    const currentIcon = L.divIcon({
      className: 'current-location-marker',
      html: '<div style="background-color: #ff6b6b; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.4);"></div>',
      iconSize: [20, 20],
      iconAnchor: [10, 10]
    });
    
    currentLocationMarker = L.marker([currentLat, currentLon], { icon: currentIcon })
      .addTo(map)
      .bindPopup(currentPlace || "Current Location");
    
    // Open popup for current location
    if (urlLat || (mapDiv && mapDiv.getAttribute("data-lat"))) {
      currentLocationMarker.openPopup();
    }
  }

  // üìç Add city markers (all Philippine cities)
  const citiesData = mapDiv ? mapDiv.getAttribute("data-cities") : null;
  let cities = [];
  
  if (citiesData) {
    try {
      cities = JSON.parse(citiesData);
    } catch (e) {
      console.error("Failed to parse cities data", e);
      // Fallback to default cities
      cities = [
        { label: "Manila", lat: 14.5995, lon: 120.9842 },
        { label: "Cebu", lat: 10.3157, lon: 123.8854 },
        { label: "Davao", lat: 7.1907, lon: 125.4553 },
        { label: "Baguio", lat: 16.4023, lon: 120.5960 },
      ];
    }
  } else {
    cities = [
      { label: "Manila", lat: 14.5995, lon: 120.9842 },
      { label: "Cebu", lat: 10.3157, lon: 123.8854 },
      { label: "Davao", lat: 7.1907, lon: 125.4553 },
      { label: "Baguio", lat: 16.4023, lon: 120.5960 },
    ];
  }

  cities.forEach((c) => {
    // Don't add marker if it's the current location (to avoid duplicate)
    const isCurrent = Math.abs(c.lat - currentLat) < 0.01 && Math.abs(c.lon - currentLon) < 0.01;
    if (!isCurrent) {
      const marker = L.marker([c.lat, c.lon]).addTo(map);
      marker.bindPopup(c.label);

      // On marker click, update weather info (stop propagation to prevent map click)
      marker.on("click", (e) => {
        if (e.originalEvent) {
          L.DomEvent.stopPropagation(e.originalEvent);
        }
        
        // Update URL to persist location
        const url = new URL(window.location);
        url.searchParams.set("lat", c.lat);
        url.searchParams.set("lon", c.lon);
        url.searchParams.set("place", c.label);
        window.history.pushState({}, "", url);

        // Remove old marker and add new one
        if (currentLocationMarker) {
          map.removeLayer(currentLocationMarker);
        }
        
        const pinIcon = L.divIcon({
          className: 'current-location-marker pinned-location',
          html: '<div style="background-color: #ff6b6b; width: 24px; height: 24px; border-radius: 50% 50% 50% 0; transform: rotate(-45deg); border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.4); position: relative;"><div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(45deg); width: 8px; height: 8px; background: white; border-radius: 50%;"></div></div>',
          iconSize: [24, 24],
          iconAnchor: [12, 24]
        });
        
        currentLocationMarker = L.marker([c.lat, c.lon], { icon: pinIcon })
          .addTo(map)
          .bindPopup(`üìç ${c.label}`);

        // Update city dropdown to match selected city
        const citySelect = document.getElementById("citySelect");
        if (citySelect) {
          // Find the city key from the cities data
          const mapDiv = document.getElementById("map");
          if (mapDiv) {
            const citiesData = mapDiv.getAttribute("data-cities");
            if (citiesData) {
              try {
                const cities = JSON.parse(citiesData);
                for (const [key, cityData] of Object.entries(cities)) {
                  if (Math.abs(cityData.lat - c.lat) < 0.01 && Math.abs(cityData.lon - c.lon) < 0.01) {
                    citySelect.value = key;
                    break;
                  }
                }
              } catch (e) {
                console.error("Failed to parse cities data", e);
              }
            }
          }
        }

        updateWeatherWithLocation(c.lat, c.lon, c.label);
      });
    }
  });

}

// Validate Philippines coordinates
function validatePhilippinesCoordinates(lat, lon) {
  if (lat < 4.2 || lat > 21.1 || lon < 116.9 || lon > 127.0) {
    return false;
  }
  return true;
}

// Constrain coordinates to Philippines bounds
function constrainToPhilippines(lat, lon) {
  lat = Math.max(4.2, Math.min(21.1, lat));
  lon = Math.max(116.9, Math.min(127.0, lon));
  return { lat, lon };
}

// Helper function to update weather with location parameters
function updateWeatherWithLocation(lat, lon, placeName, days = null, type = null) {
  // Validate coordinates are within Philippines
  if (!validatePhilippinesCoordinates(lat, lon)) {
    alert("‚ö†Ô∏è Location must be within Philippines boundaries. Please select a location in the Philippines.");
    return;
  }
  
  const url = new URL(window.location);
  url.searchParams.set("lat", lat.toString());
  url.searchParams.set("lon", lon.toString());
  url.searchParams.set("place", placeName);
  if (days) url.searchParams.set("days", days.toString());
  if (type) url.searchParams.set("type", type);
  window.history.pushState({}, "", url);
  
  htmx.ajax("GET", "/partial/page", {
    target: "#pageShell",
    swap: "innerHTML",
    values: {
      lat: lat.toString(),
      lon: lon.toString(),
      place: placeName,
      days: days || document.getElementById("dateRange")?.value || "7",
      type: type || document.getElementById("dataType")?.value || "temperature",
    },
  });
}

// Function to update weather with current location and selected days
function updateWeatherWithCurrentLocation(days) {
  const urlParams = new URLSearchParams(window.location.search);
  const lat = urlParams.get("lat");
  const lon = urlParams.get("lon");
  const place = urlParams.get("place");
  const citySelect = document.getElementById("citySelect");
  const dataType = document.getElementById("dataType")?.value || "temperature";
  
  // Limit days to 30
  const daysValue = Math.min(parseInt(days) || 7, 30);
  
  // Update hidden inputs
  const hiddenLat = document.getElementById("hiddenLat");
  const hiddenLon = document.getElementById("hiddenLon");
  const hiddenPlace = document.getElementById("hiddenPlace");
  
  if (lat && lon) {
    // Use pinned location
    if (hiddenLat) hiddenLat.value = lat;
    if (hiddenLon) hiddenLon.value = lon;
    if (hiddenPlace && place) hiddenPlace.value = place;
    updateWeatherWithLocation(parseFloat(lat), parseFloat(lon), place || "Pinned Location", daysValue.toString(), dataType);
  } else if (citySelect) {
    // Use selected city - clear location params
    if (hiddenLat) hiddenLat.value = "";
    if (hiddenLon) hiddenLon.value = "";
    if (hiddenPlace) hiddenPlace.value = "";
    const city = citySelect.value;
    htmx.ajax("GET", "/partial/page", {
      target: "#pageShell",
      swap: "innerHTML",
      values: {
        city: city,
        days: daysValue.toString(),
        type: dataType,
      },
    });
  }
}

// Function to find matching city for coordinates
function findMatchingCity(lat, lon) {
  const mapDiv = document.getElementById("map");
  if (!mapDiv) return null;
  
  const citiesData = mapDiv.getAttribute("data-cities");
  if (!citiesData) return null;
  
  try {
    const cities = JSON.parse(citiesData);
    // Check if coordinates match any city (within 0.1 degree tolerance)
    for (const [key, city] of Object.entries(cities)) {
      if (Math.abs(city.lat - lat) < 0.1 && Math.abs(city.lon - lon) < 0.1) {
        return key;
      }
    }
  } catch (e) {
    console.error("Failed to parse cities data", e);
  }
  return null;
}

// Function to update weather when city is selected
function updateWeatherWithCity(city) {
  const urlParams = new URLSearchParams(window.location.search);
  const lat = urlParams.get("lat");
  const lon = urlParams.get("lon");
  
  // Get city coordinates from cities data
  const mapDiv = document.getElementById("map");
  let cityLat = null;
  let cityLon = null;
  let cityLabel = city;
  
  if (mapDiv) {
    const citiesData = mapDiv.getAttribute("data-cities");
    if (citiesData) {
      try {
        const cities = JSON.parse(citiesData);
        const cityData = cities[city];
        if (cityData) {
          cityLat = cityData.lat;
          cityLon = cityData.lon;
          cityLabel = cityData.label || city;
        }
      } catch (e) {
        console.error("Failed to parse cities data", e);
      }
    }
  }
  
  // Clear URL params and update with city location
  const url = new URL(window.location);
  url.searchParams.delete("lat");
  url.searchParams.delete("lon");
  url.searchParams.delete("place");
  
  // If city has coordinates, set them in URL and update map pin
  if (cityLat !== null && cityLon !== null) {
    url.searchParams.set("lat", cityLat.toString());
    url.searchParams.set("lon", cityLon.toString());
    url.searchParams.set("place", cityLabel);
    window.history.pushState({}, "", url);
    
    // Update map pin if map is available
    if (mapInstance && currentLocationMarker) {
      mapInstance.removeLayer(currentLocationMarker);
    }
    
    if (mapInstance) {
      const pinIcon = L.divIcon({
        className: 'current-location-marker pinned-location',
        html: '<div style="background-color: #ff6b6b; width: 24px; height: 24px; border-radius: 50% 50% 50% 0; transform: rotate(-45deg); border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.4); position: relative;"><div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(45deg); width: 8px; height: 8px; background: white; border-radius: 50%;"></div></div>',
        iconSize: [24, 24],
        iconAnchor: [12, 24]
      });
      
      currentLocationMarker = L.marker([cityLat, cityLon], { icon: pinIcon, draggable: false })
        .addTo(mapInstance)
        .bindPopup(`üìç ${cityLabel}`, { autoClose: false })
        .openPopup();
      
      mapInstance.setView([cityLat, cityLon], 12);
    }
  } else {
    window.history.pushState({}, "", url);
    
    // Remove map pin if switching to a city without coordinates
    if (mapInstance && currentLocationMarker) {
      mapInstance.removeLayer(currentLocationMarker);
      currentLocationMarker = null;
    }
  }
  
  const days = document.getElementById("dateRange")?.value || "7";
  const type = document.getElementById("dataType")?.value || "temperature";
  
  htmx.ajax("GET", "/partial/page", {
    target: "#pageShell",
    swap: "innerHTML",
    values: {
      city: city,
      days: days,
      type: type,
    },
  });
}

// Function to update weather when data type is selected
function updateWeatherWithDataType(type) {
  const urlParams = new URLSearchParams(window.location.search);
  const lat = urlParams.get("lat");
  const lon = urlParams.get("lon");
  const place = urlParams.get("place");
  const days = document.getElementById("dateRange")?.value || "7";
  
  if (lat && lon) {
    updateWeatherWithLocation(parseFloat(lat), parseFloat(lon), place || "Pinned Location", days, type);
  } else {
    const city = document.getElementById("citySelect")?.value || "manila";
    htmx.ajax("GET", "/partial/page", {
      target: "#pageShell",
      swap: "innerHTML",
      values: {
        city: city,
        days: days,
        type: type,
      },
    });
  }
}

// Function to initialize search box functionality
function initializeSearchBox(map) {
  const input = document.getElementById("mapSearchInput");
  const suggestionBox = document.getElementById("searchSuggestions");

  if (!input || !suggestionBox) {
    console.warn("Search elements not found, retrying...");
    setTimeout(() => initializeSearchBox(map), 200);
    return;
  }

  let timeout = null;
  let currentSuggestions = [];

  // Function to update weather when location is selected
  function updateWeatherForLocation(lat, lon, placeName) {
    // Remove old current location marker
    if (currentLocationMarker) {
      map.removeLayer(currentLocationMarker);
    }

    // Add new current location marker with pin icon
    const pinIcon = L.divIcon({
      className: 'current-location-marker pinned-location',
      html: '<div style="background-color: #ff6b6b; width: 24px; height: 24px; border-radius: 50% 50% 50% 0; transform: rotate(-45deg); border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.4); position: relative;"><div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(45deg); width: 8px; height: 8px; background: white; border-radius: 50%;"></div></div>',
      iconSize: [24, 24],
      iconAnchor: [12, 24]
    });
    currentLocationMarker = L.marker([lat, lon], { icon: pinIcon, draggable: false })
      .addTo(map)
      .bindPopup(`üìç ${placeName}`, { autoClose: false })
      .openPopup();

    // Move map to location
    map.setView([lat, lon], 12);

    // Use helper function to update weather
    updateWeatherWithLocation(lat, lon, placeName);

    if (suggestionBox) suggestionBox.innerHTML = "";
    if (input) input.value = placeName;
  }

  // Handle input typing for live suggestions
  input.addEventListener("input", async (e) => {
    clearTimeout(timeout);
    const query = e.target.value.trim();

    if (query.length < 2) {
      if (suggestionBox) suggestionBox.innerHTML = "";
      currentSuggestions = [];
      return;
    }

        timeout = setTimeout(async () => {
          try {
            const response = await fetch(
              `https://nominatim.openstreetmap.org/search?format=json&countrycodes=ph&q=${encodeURIComponent(query)}&limit=5&viewbox=116.9,21.1,127.0,4.2&bounded=1`
            );
            const results = await response.json();
            // Filter results to ensure they're within Philippines bounds
            const phResults = results.filter(r => 
              validatePhilippinesCoordinates(parseFloat(r.lat), parseFloat(r.lon))
            );
            currentSuggestions = phResults;

            if (phResults.length > 0 && suggestionBox) {
              suggestionBox.innerHTML = phResults
                .map((r, index) => {
                  const nameParts = r.display_name.split(",");
                  const mainName = nameParts[0] || "Unknown";
                  const subText = nameParts.slice(1, 3).join(", ") || "";

                  return `
              <div class="suggestion-item ${index === 0 ? 'highlighted' : ''}"
                data-lat="${r.lat}"
                data-lon="${r.lon}"
                data-name="${r.display_name}">
                <div class="suggestion-main">${mainName}</div>
                <div class="suggestion-sub">${subText}</div>
              </div>`;
                })
                .join("");
            } else if (suggestionBox) {
              suggestionBox.innerHTML = "<div class='no-result'>No results found in Philippines</div>";
            }
      } catch (err) {
        console.error("Search failed:", err);
        if (suggestionBox) suggestionBox.innerHTML = "<div class='no-result'>Search error. Try again.</div>";
      }
    }, 400);
  });

  // Handle Enter key - select first suggestion
  input.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && currentSuggestions.length > 0) {
      e.preventDefault();
      const firstResult = currentSuggestions[0];
      updateWeatherForLocation(
        parseFloat(firstResult.lat),
        parseFloat(firstResult.lon),
        firstResult.display_name.split(",")[0]
      );
    } else if (e.key === "Escape") {
      if (suggestionBox) suggestionBox.innerHTML = "";
      currentSuggestions = [];
    }
  });

  // üñ±Ô∏è Handle click on a suggestion
  suggestionBox.addEventListener("click", (e) => {
    const item = e.target.closest(".suggestion-item");
    if (!item) return;

    const lat = parseFloat(item.dataset.lat);
    const lon = parseFloat(item.dataset.lon);
    const placeName = item.dataset.name.split(",")[0];

    updateWeatherForLocation(lat, lon, placeName);
  });
}

// ‚ôªÔ∏è Reinitialize after HTMX updates page content
document.body.addEventListener("htmx:afterSwap", (event) => {
  if (event.detail.target.id === "pageShell") {
    // Preserve current location from URL params
    const urlParams = new URLSearchParams(window.location.search);
    const preservedLat = urlParams.get("lat");
    const preservedLon = urlParams.get("lon");
    const preservedPlace = urlParams.get("place");
    
    // Re-initialize map and real-time updates after content swap
    setTimeout(() => {
      initLeafletMap();
      initRealTimeUpdates();
      
      // Restore marker if we have preserved location
      if (preservedLat && preservedLon && mapInstance) {
        setTimeout(() => {
          const lat = parseFloat(preservedLat);
          const lon = parseFloat(preservedLon);
          
          if (currentLocationMarker) {
            mapInstance.removeLayer(currentLocationMarker);
          }
          
          // Use pin icon for restored location
          const restorePinIcon = L.divIcon({
            className: 'current-location-marker pinned-location',
            html: '<div style="background-color: #ff6b6b; width: 24px; height: 24px; border-radius: 50% 50% 50% 0; transform: rotate(-45deg); border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.4); position: relative;"><div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(45deg); width: 8px; height: 8px; background: white; border-radius: 50%;"></div></div>',
            iconSize: [24, 24],
            iconAnchor: [12, 24]
          });
          
          currentLocationMarker = L.marker([lat, lon], { icon: restorePinIcon })
            .addTo(mapInstance)
            .bindPopup(`üìç ${preservedPlace || "Current Location"}`);
          
          mapInstance.setView([lat, lon], 12);
          
          // Check if restored location matches any city and update dropdown
          const matchingCity = findMatchingCity(lat, lon);
          const citySelect = document.getElementById("citySelect");
          if (matchingCity && citySelect) {
            citySelect.value = matchingCity;
          }
        }, 250);
      }
    }, 100);
  }
});


// Toggle between 7-day forecast and real-time info in sidebar
function toggleSidebarView() {
  const forecastView = document.getElementById("miniForecast");
  const realtimeView = document.getElementById("realtimeInfo");
  const toggleText = document.getElementById("toggleText");
  
  if (!forecastView || !realtimeView || !toggleText) return;
  
  if (forecastView.style.display === "none") {
    // Switch to forecast view
    forecastView.style.display = "flex";
    realtimeView.style.display = "none";
    toggleText.textContent = "üìÖ 7-Day Forecast";
  } else {
    // Switch to real-time view
    forecastView.style.display = "none";
    realtimeView.style.display = "block";
    toggleText.textContent = "üîÑ Real-Time Info";
    // Update real-time data
    updateRealtimeSidebar();
  }
}

// Update real-time info in sidebar
function updateRealtimeSidebar() {
  const updateElement = (id, value) => {
    const el = document.getElementById(id);
    if (el && value !== null && value !== undefined) {
      el.textContent = value;
    }
  };
  
  // Get current values from sidebar or make API call
  const sidebarTemp = document.getElementById("sidebarTemp");
  const sidebarHumidity = document.getElementById("sidebarHumidity");
  const sidebarPressure = document.getElementById("sidebarPressure");
  const sidebarWind = document.getElementById("sidebarWind");
  
  if (sidebarTemp) {
    const tempText = sidebarTemp.textContent.replace("üå° ", "").replace("¬∞C", "");
    updateElement("realtimeTemp", tempText + "¬∞C");
  }
  if (sidebarHumidity) {
    const humText = sidebarHumidity.textContent.replace("üíß ", "").replace("%", "");
    updateElement("realtimeHumidity", humText + "%");
  }
  if (sidebarPressure) {
    const pressText = sidebarPressure.textContent.replace("üîµ ", "").replace(" hPa", "");
    updateElement("realtimePressure", pressText + " hPa");
  }
  if (sidebarWind) {
    const windText = sidebarWind.textContent.replace("üí® ", "").replace(" km/h", "");
    updateElement("realtimeWind", windText + " km/h");
  }
  
  // Update timestamp
  const timestampEl = document.getElementById("realtimeTimestamp");
  if (timestampEl) {
    const now = new Date();
    timestampEl.textContent = `Last updated: ${now.toLocaleTimeString()}`;
  }
}

// üöÄ Initialize on first load
document.addEventListener("DOMContentLoaded", () => {
  // Hide splash screen after page loads
  setTimeout(() => {
    const splashScreen = document.getElementById("splashScreen");
    if (splashScreen) {
      splashScreen.classList.add("fade-out");
      setTimeout(() => {
        splashScreen.style.display = "none";
      }, 500);
    }
    
    initLeafletMap();
    initRealTimeUpdates();
  }, 1500); // Show splash for 1.5 seconds
});

// üîÑ Real-time auto-refresh functionality
let refreshInterval = null;
let currentRefreshInterval = 60000; // 1 minute default

function initRealTimeUpdates() {
  const toggle = document.getElementById("autoRefreshToggle");
  const intervalSelect = document.getElementById("refreshInterval");
  
  if (!toggle || !intervalSelect) return;
  
  // Start auto-refresh by default
  startAutoRefresh();
  
  toggle.addEventListener("change", (e) => {
    if (e.target.checked) {
      startAutoRefresh();
    } else {
      stopAutoRefresh();
    }
  });
  
  intervalSelect.addEventListener("change", (e) => {
    currentRefreshInterval = parseInt(e.target.value) * 1000;
    if (toggle.checked) {
      stopAutoRefresh();
      startAutoRefresh();
    }
  });
}

function startAutoRefresh() {
  stopAutoRefresh(); // Clear any existing interval
  refreshInterval = setInterval(() => {
    updateCurrentWeather();
  }, currentRefreshInterval);
  updateIndicatorStatus(true);
}

function stopAutoRefresh() {
  if (refreshInterval) {
    clearInterval(refreshInterval);
    refreshInterval = null;
  }
  updateIndicatorStatus(false);
}

function updateIndicatorStatus(isActive) {
  const indicator = document.getElementById("realTimeIndicator");
  if (indicator) {
    indicator.classList.toggle("active", isActive);
  }
}

async function updateCurrentWeather() {
  try {
    // Get location from multiple sources
    const urlParams = new URLSearchParams(window.location.search);
    const citySelect = document.getElementById("citySelect");
    const mapElement = document.querySelector("#map[data-lat]");
    
    let lat = urlParams.get("lat");
    let lon = urlParams.get("lon");
    let city = urlParams.get("city") || (citySelect ? citySelect.value : null);
    let place = urlParams.get("place");
    
    // Fallback to map data attributes
    if (!lat && mapElement) {
      lat = mapElement.dataset.lat;
      lon = mapElement.dataset.lon;
    }
    
    if (!lat && !city) return;
    
    const params = new URLSearchParams();
    if (lat && lon) {
      params.append("lat", lat);
      params.append("lon", lon);
      if (place) params.append("place", place);
    } else if (city) {
      params.append("city", city);
    }
    
    const response = await fetch(`/api/current?${params.toString()}`);
    const data = await response.json();
    
    if (data.success) {
      // Update current conditions
      updateCurrentConditions(data.current);
      
      // Update alerts
      updateAlerts(data.alerts || []);
      
      // Update last update time
      const updateTimeEl = document.getElementById("lastUpdateTime");
      if (updateTimeEl) {
        const time = new Date(data.timestamp).toLocaleTimeString();
        updateTimeEl.textContent = `Updated: ${time}`;
      }
      
      // Flash indicator
      flashIndicator();
    }
  } catch (error) {
    console.error("Failed to update weather:", error);
  }
}

function updateCurrentConditions(current) {
  const updateElement = (id, value, suffix = "", prefix = "") => {
    const el = document.getElementById(id);
    if (el) {
      if (value !== null && value !== undefined && value !== "N/A") {
        el.textContent = `${prefix}${value}${suffix}`;
        // Add animation
        el.style.animation = "none";
        setTimeout(() => {
          el.style.animation = "pulse 0.5s ease";
        }, 10);
      } else {
        // Show N/A if value is missing
        el.textContent = `${prefix}N/A${suffix}`;
      }
    }
  };
  
  // Update main content area
  updateElement("currentTemp", current.temperature, "¬∞C", "üå° ");
  updateElement("currentHumidity", current.humidity, "%", "üíß ");
  updateElement("currentPressure", current.pressure, " hPa", "üîµ ");
  updateElement("currentWind", current.windspeed, " km/h", "üí® ");
  
  // Update sidebar elements
  updateElement("sidebarTemp", current.temperature, "¬∞C", "üå° ");
  updateElement("sidebarHumidity", current.humidity, "%", "üíß ");
  updateElement("sidebarPressure", current.pressure, " hPa", "üîµ ");
  updateElement("sidebarWind", current.windspeed, " km/h", "üí® ");
  
  // Update real-time info view if it's visible
  const realtimeView = document.getElementById("realtimeInfo");
  if (realtimeView && realtimeView.style.display !== "none") {
    updateElement("realtimeTemp", current.temperature, "¬∞C");
    updateElement("realtimeHumidity", current.humidity, "%");
    updateElement("realtimePressure", current.pressure, " hPa");
    updateElement("realtimeWind", current.windspeed, " km/h");
    
    // Update timestamp
    const timestampEl = document.getElementById("realtimeTimestamp");
    if (timestampEl) {
      const now = new Date();
      timestampEl.textContent = `Last updated: ${now.toLocaleTimeString()}`;
    }
  }
  
  // Update weather icon if available (icon already updated via template)
  // Sidebar icon is managed by the server-side template rendering
}

function updateAlerts(alerts) {
  const alertContainer = document.getElementById("weatherAlert");
  if (!alertContainer) return;
  
  if (alerts.length === 0) {
    alertContainer.innerHTML = "";
    return;
  }
  
  alertContainer.innerHTML = alerts.map(alert => `
    <div class="alert alert-${alert.severity}">
      ${alert.message}
    </div>
  `).join("");
}

function flashIndicator() {
  const indicator = document.getElementById("realTimeIndicator");
  if (indicator) {
    indicator.classList.add("flash");
    setTimeout(() => indicator.classList.remove("flash"), 1000);
  }
}

</script>


<style>
/* Optional search box focus style */
.search-container input:focus {
  outline: none;
  border-color: #4caf50;
  box-shadow: 0 0 4px #4caf50;
}
</style>



</body>
</html>
